# チャットチャンネル仕様(案)

## 概要

AIとの壁打ちによるアイデア出しを目的とした機能。
現状のAIチャット機能では、履歴の保存や内容の改変ができないため、ドキュメントとして保存できるチャットチャンネル機能を追加する。

## 想定される用途

- **AIとの壁打ちの記録**: 特定のテーマ（プロット、世界観設定など）に沿ったAIとの質疑応答をファイルとして永続化する。
- **履歴改変からの会話再開**: 過去の回答を人間が編集・ブラッシュアップした状態から、その文脈を引き継いでAIと対話を継続する。
- **過去の会話の再開**: 数日・数週間前の会話内容をファイルとして開き、いつでも当時の文脈で続きを話せるようにする。
- **並行チャンネルの運用**: 「キャラ設定用」「世界観構築用」「プロット相談用」など、複数のチャットファイルを同時に開き、異なる文脈で並行して議論を進める。

## 実現性の検討

既存のエディター基盤と AI プロバイダーの仕組みを組み合わせることで、上記の用途は以下の通り実現可能です。

- **文脈の再構築**: `.ch` ファイルを開いた際、`messages` 配列の内容をそのまま AI プロバイダーの `chat()` メソッドに渡す履歴情報として利用します。これにより、ファイル内容（人間による編集後を含む）がそのまま AI にとっての「既知の会話」となります。
- **並行処理とセッション管理**:
    - **現状の課題**: 現在の `AIService` は単一の IPC チャンネル（ `ai:streamChat:data` ）を使用しているため、複数のタブで同時に AI が生成を行うと、レンダラー側で応答が混ざる可能性があります。
    - **解決策**: メッセージ送信時に識別子として **ファイルパス（ `path` ）** をメインプロセスに渡し、返答（ `reply` ）にもこのパスを含めるように拡張します。
    - **実現性**: ファイルパスはドキュメントを一意に特定できるため、レンダラー側でのタブごとのルーティングに最適です。なお、未保存（untitled）の場合は一時的な内部 ID を使用しますが、基本的にはパスを識別子とすることで、複数のチャンネルでの完全な並行処理が可能です。
- **編集の即時反映**: `CodeEditor` または `ChView` での変更はメモリ上の `tabContents` を通じてファイルに同期されるため、常に「最新の編集済み履歴」に基づいて AI とのやり取りが行われます。

## 要件

* チャットの機能は、現状のAIチャット機能と同様とする。
* チャットチャンネルは、ファイルとして保存される。
  + 編集のUIを持つか？
  + 現状の他でのプレビューとは逆に編集画面への遷移をもたせる？
  + チャットUI上で編集機能を持つ？
    + 実用上はこれぐらいで良い？
  + ファイルのフォーマットを人間寄りにするか、プログラムよりにするか？
    + 実験的には内部JSONでも良い？
* 履歴の改変等が可能
  + 要はチャットに渡す内容を遡って調整しやすいようにする。
* 実際にチャットしてなくてもAI側の発言含めて登録可能
  + AI関連プログラムでは内部で行っているが、それをユーザーができるようにする。
  + デバッグとしても楽なのでは？

## ファイル名および拡張子

- 文末の拡張子を **`.ch`** とします（例: `001_構成案.ch`）。
- ファイル名の先頭に `#` を付ける運用（例: `#構成案.ch`）も許容します。
- 将来的に JSON 以外の形式への移行や、プレーンテキストに近い形での管理の可能性を考慮し、`.json` は含めません。

## ファイル構造とフォーマット

現時点では JSON 互換の形式を採用しますが、人間が直接テキストエディターで編集しやすいことを重視します。

### JSON 構造詳細

```json
{
    "version": "1.0",
    "metadata": {
        "title": "チャットのタイトル",
        "description": "チャットの概要説明",
        "createdAt": "20260222170000",
        "updatedAt": "20260222170530",
        "defaultPersonaId": "wanta",
        "defaultRoleId": "assistant",
        "parameters": {
            "temperature": 0.7,
            "maxTokens": 2048
        }
    },
    "messages": [
        {
            "id": "msg-1",
            "role": "user",
            "content": "構成案を考えて。",
            "timestamp": "20260222170000"
        },
        {
            "id": "msg-2",
            "role": "assistant",
            "agentId": "wanta",
            "name": "猫乃わん太",
            "parts": [
                {
                    "type": "text",
                    "content": "了解だわん！"
                }
            ],
            "timestamp": "20260222170005"
        }
    ]
}
```

#### 各フィールドの説明
- **metadata**: チャット全体の属性。
    - `defaultPersonaId`: デフォルトで使用するペルソナ（エージェント）のID。
- **messages**: 会話履歴の配列。
    - `id`: メッセージの一意識別子。
    - `role`: `user`, `assistant`, `system` のいずれか。
    - `agentId`: AIが発言した際のエージェントID。これにより、現在のエージェント設定が変更されても、過去の発言時のアイコンや名前を正しく表示できる。
    - `name`: 発言時の表示名。
    - `parts`: 思考 (`thought`) と本文 (`text`) を分けるための構造。既存の `AIChatPanel` との互換性のために保持。単一のテキストの場合は `content` フィールドのみでも可とする。
    - `timestamp`: 人間が直接編集・可読できるように、UNIXタイムスタンプではなく **`yyyyMMddHHmmss`** 形式の文字列とします。

## 実装方針

### ドキュメントビューとしての扱い
チャットチャンネルは、中央のメインドキュメント領域にタブとして開かれます。

1. **初期段階（UI実装前）**:
   - `.ch` ファイルを開いた際、通常の JSON ファイルと同様に **`CodeEditor` で開き、直接テキストを編集**して保存する運用とします。
   - Monaco Editor の JSON 言語モード等を適用し、シンタックスハイライトを利用可能にします。

2. **UI実装後（ChView）**:
   - 専用のチャットUI（`ChView`）が実装された後は、デフォルトでその View が開きますが、タブの切り替えや右クリックメニューからいつでも `CodeEditor`（生データ編集）に戻れるようにします。

### コンポーネント構成
- `src/renderer/components/ch/` 配下に新規作成。
- `ChView`: メイン領域に表示されるコンポーネント。スクロール可能なメッセージリストと入力エリアを含む。
- `ChMessage`: 個別の発言の表示。

### エディター統合
- `MainLayout.tsx` で `.ch` 拡張子を検知します。
- UI 実装までは、内部的に `language: 'json'` 等として `CodeEditor` に渡します。

### エージェント情報の取得
- `agentId` が指定されている場合、アプリ内の既存ペルソナ定数 (`PERSONAS`) または動的なペルソナ（メタデータからスキャンされたもの）からアイコンや名前を取得します。
- 万が一エージェントが削除された場合でも表示を維持するため、発言時の `name` はメッセージ内に保持します。

### オートセーブ
- メッセージが送信されるたび、またはAIからの返答が完了するたびに、ファイルを自動的にプロジェクト内（ファイルシステム）へ保存します。
- これにより、「書きかけの会話」が常に最新の状態でドキュメントとして永続化されます。

---

## 将来的な拡張案：ドキュメント間・複数エージェント対話

将来的に、異なるエージェント同士の直接対話や、複数のエージェントが参加する会話（グループチャット形式）の実現を検討します。

### role と agentId の役割分担案
複数エージェント対話を実現するため、`role` は AI モデルに対する「論理的な指示」として維持し、`agentId` で「発言の主体」を定義する方針とします。

- **`role` (論理的な役割)**:
    - AI モデル（LLM）にメッセージを渡す際の `user` / `assistant` という区分として使用します。
    - **Agent vs Agent の場合**: 応答を生成しようとしているエージェント A にとって、相手のエージェント B の発言は「外部からの入力（ `user` ）」として扱われます。
- **`agentId` (発言の実体)**:
    - 誰が発言したかを一意に特定するために使用します。
    - ユーザー（人間）の場合は `agentId: "user"` のような固定値を検討します。

### 実現のためのデータ構造
```json
{
    "messages": [
        {
            "id": "msg-x",
            "role": "assistant",
            "agentId": "agent-a",
            "name": "エージェントA",
            "content": "エージェントBさん、このプロットについてどう思いますか？"
        },
        {
            "id": "msg-y",
            "role": "assistant",
            "agentId": "agent-b",
            "name": "エージェントB",
            "content": "エージェントAさん、とても面白いと思います。特に後半の..."
        }
    ]
}
```

### 多対多対話の実現性
- **文脈構築時の工夫**: エージェント B の返答を生成する際、履歴内の `agentId` が自分以外（エージェント A や人間）のメッセージをすべて `role: "user"` とした上で、内容の先頭に `[エージェントA]: ` のようなプレフィックスを付けて LLM に渡すことで、誰の発言かをモデルに認識させることが可能です。
- **ドキュメント間の連携**: 別の `.ch` ファイルで定義されたエージェント設定や会話ログを参照し、それに基づいた別チャンネルでの議論なども、このデータ構造であれば `agentId` をキーにした検索・統合により実現性が高いと考えられます。
